<!DOCTYPE html>
<html>
<head>
    <title>Mines Verifier - Last Row Focus</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script type="importmap">
        {
            "imports": {
                "crypto-js": "https://esm.sh/crypto-js"
            }
        }
    </script>
    <style>
        .tile { width: 40px; height: 40px; border: 1px solid #ccc; display: inline-block; margin: 2px; }
        .mine { background-color: red; }
        .safe { background-color: green; }
        .suggested { border: 3px solid blue; }
        #gameCanvas { margin-top: 20px; }
    </style>
</head>
<body>
    <h2>Mines Verifier – Focus on Last Row</h2>
    <form id="inputForm">
        <label>Server Seed: <input type="text" id="server_seed" value=""></label><br>
        <label>Client Seed: <input type="text" id="client_seed" value=""></label><br>
        <label>Game Seed: <input type="text" id="game_seed" value=""></label><br>
        <label>Mines Count: <select id="mines_count"></select></label><br>
        <label>Game ID (optional): <input type="text" id="game_id" value="mines"></label><br>
        <button type="button" id="calc">Calculate Mines</button>
        <button type="button" id="suggest">Suggest Last Row Pick</button>
    </form>
    <div id="gameCanvas"></div>
    <div id="result"></div>

    <script type="module">
        import CryptoJS from "https://esm.sh/crypto-js";

        // Constants
        const bits = 53;
        const bytes = Math.floor(bits / 4);
        const maxValue = Math.pow(2, bits - 1);
        const GRID_SIZE = 25; // 5x5
        const ROWS = 5;
        const COLS = 5;

        // Helper: get HMAC hash
        function getHash({ gameId = "mines", serverSeed, clientSeed, gameSeed, cursor }) {
            return CryptoJS.HmacSHA256(
                `${gameId}:${clientSeed}:${gameSeed}:${cursor}`,
                serverSeed
            ).toString();
        }

        // Generate mine positions (original logic, corrected)
        function generateMines({ serverSeed, clientSeed, gameSeed, minesCount, gridSize = GRID_SIZE }) {
            const positions = Array.from({ length: gridSize }, (_, i) => i);
            let cursor = 0;
            let hashCursor = 0;
            let hash = getHash({ serverSeed, clientSeed, gameSeed, cursor });

            for (let i = positions.length - 1; i > 0; i--) {
                let outcome = hash.slice(hashCursor, hashCursor + bytes);

                if (outcome.length < bytes) {
                    cursor++;
                    hash = getHash({ serverSeed, clientSeed, gameSeed, cursor });
                    hashCursor = 0;
                    outcome = hash.slice(hashCursor, hashCursor + bytes);
                }

                const outcomeNum = parseInt(outcome, 16) / maxValue;
                const j = Math.floor(outcomeNum * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
                hashCursor += bytes;
            }

            return positions.slice(0, minesCount);
        }

        // Get safe tiles in a given row (0-indexed rows: 0 = row1, 4 = row5)
        function getSafeTilesInRow(mines, rowIndex = 4) {
            const start = rowIndex * COLS;
            const end = start + COLS;
            const safe = [];
            for (let i = start; i < end; i++) {
                if (!mines.includes(i)) safe.push(i);
            }
            return safe;
        }

        // Draw the game grid with mines and optional suggested tile
        function generateGameCanvas(mines = [], suggestedTile = null) {
            const gameCanvas = $("#gameCanvas");
            gameCanvas.empty();

            for (let i = 0; i < GRID_SIZE; i++) {
                const el = document.createElement("div");
                el.classList.add("tile");
                if (mines.includes(i)) {
                    el.classList.add("mine");
                } else {
                    el.classList.add("safe");
                }
                if (suggestedTile === i) {
                    el.classList.add("suggested");
                }
                // Optional: show tile number
                el.title = `Tile ${i}`;
                gameCanvas.append(el);
            }
        }

        // Populate mines count dropdown
        function addMinesOptions() {
            const $select = $("#mines_count");
            $select.empty();
            for (let i = 1; i <= 24; i++) {
                $select.append(`<option value="${i}">${i}</option>`);
            }
        }
        addMinesOptions();

        // Read URL parameters
        function getQueryVariable(variable) {
            const query = window.location.search.substring(1);
            const vars = query.split("&");
            for (let i = 0; i < vars.length; i++) {
                const pair = vars[i].split("=");
                if (decodeURIComponent(pair[0]) === variable) {
                    return decodeURIComponent(pair[1] || "");
                }
            }
            return null;
        }

        // Main calculation function
        function calculateResult() {
            const serverSeed = $("#server_seed").val();
            const clientSeed = $("#client_seed").val();
            const gameSeed = $("#game_seed").val();
            const gameId = $("#game_id").val() || "mines";
            const minesCount = parseInt($("#mines_count").val(), 10);

            if (!serverSeed || !clientSeed || !gameSeed || isNaN(minesCount)) {
                alert("Please fill all fields");
                return;
            }

            const mines = generateMines({
                serverSeed,
                clientSeed,
                gameSeed,
                minesCount,
                gameId
            });

            generateGameCanvas(mines);
            $("#result").text(`Mines at positions: ${mines.join(', ')}`);
            return mines;
        }

        // Suggest a safe tile in the last row
        function suggestLastRow() {
            const mines = calculateResult(); // recalc and draw
            if (!mines) return;

            const safeTiles = getSafeTilesInRow(mines, 4); // row 5 (index 4)
            if (safeTiles.length === 0) {
                $("#result").append(" | No safe tiles in last row! (All mines)");
                return;
            }

            // Choose the first safe tile (or random – uncomment the next line for random)
            const suggested = safeTiles[0];
            // const suggested = safeTiles[Math.floor(Math.random() * safeTiles.length)];

            generateGameCanvas(mines, suggested);
            $("#result").html(`Mines: ${mines.join(', ')} | Last row safe tiles: ${safeTiles.join(', ')} | Suggested pick: Tile ${suggested} (row5, col${suggested % 5 + 1})`);
        }

        // Initialize on page load
        $(function() {
            // Fill from URL parameters if present
            const qClient = getQueryVariable("client_seed");
            const qGame = getQueryVariable("game_seed");
            const qServer = getQueryVariable("server_seed");
            const qMines = getQueryVariable("mines_count");

            if (qClient && qClient !== "undefined") $("#client_seed").val(qClient);
            if (qGame && qGame !== "undefined") $("#game_seed").val(qGame);
            if (qServer && qServer !== "undefined") $("#server_seed").val(qServer);
            if (qMines && qMines !== "undefined") $("#mines_count").val(qMines);

            $("#calc").click(calculateResult);
            $("#suggest").click(suggestLastRow);

            // Auto-run if all fields are filled
            if ($("#client_seed").val() && $("#game_seed").val() && $("#server_seed").val() && $("#mines_count").val()) {
                calculateResult();
            }
        });
    </script>
</body>
</html>
